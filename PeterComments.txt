List of possible improvements

1)  Importance: Not urgent ;  type: Interfacing improvement ; 
Currently we only interface PhaseTracer and TranbsitionSolver via text file output, would be better to pass directly and ensure maximum effiency.    On PT side  should add a routine to return phase_structure object rather than writing to file.

2) Importance: minor; type: examples tidy up 

When I run the barebones example I first get an empty figure pop up and then only after I close it do i get the proper figures appearing.    Possibly its an issue with my texlive distribution.

## DONE: variation is from PhaseTracer numerics, we know about these and can set seed  
## 4 ) Importance: medium; type: understanding numerics
##  Results vary slightly from run to run, which may make users
##  suspicious and is annoying for testing.
##  But we may also need to quantify the degree to which they match
##  to avoid users thinking small deviations that come from numerical
##  noise means it can't work

## IGNORE/RESOLVED
## 5) Importance: minor; type: output tidy up ;  status: addressed

## Actually most output is switched off by setting bDebug = False.

## I think its not desirable to always print so much to screen while
## the code runs.  Can we make an option to pipe to some log file.
## Check this is not already done in scan code.

# 6) Importance: low ; type: user illustration improvement ; status:
# addressed
# I just added a comment explaining how to do this above the one in
# barebones example. Maybe that is enough.

# Do we or could we add an example where we just enter the
# parameterPoint in code rather than loading from file? (I just
# deleted some commented out code that looked like this...). Without
# this I think a user would need to look into the code (check this
# makes sense before adding)


## IGNORE/RESOLVED:
## 7)  Importance: low to medium; type: code confusion or memory efficiency

## Why have phaseStructure output by the load_data method of
## phaseStructure, seems odd " bFileExists, phaseStructure =
## phase_structure.load_data".  Does this mean we have two copies of this
## object in memory? Looking inside this method load_data does construct
## a phaseStructure object inside it.  Actually I see no reason why
## load_data should be a method of phaseStructure when its written this
## way.

## OK I just looked at this again, it seems the simple asnwer is
## load_data is not a method of the class PhaseStructure, as indictaed
## by the lack of indentation. Its just a function thats defined in
## the same file (module I guess).  I think the confusion here is the line:

##  bFileExists, phaseStructure =
##  phase_structure.load_data(outputFolder + '/phase_structure.dat',
##  bExpectFile=True)

## To me this looked like a phase_structure object calling a method.
## But its not its a function from the imported module
## phase_structure being called.  That function the creates an object
## from the class PhaseStructure which is the second of the two
## outputs.


8)  Importance: low; type: code style, status: just for discussion

The notifyHandler and notify_TransitionAnalyser_on_create is something I am not used to.  After reading I think this could be replaced in barebones example by juts passing a Boolean flag (or set of flags) that is later used to set bComputeSubsampledThermalParams.  Maybe there is some utility to this fancy machinery later on, but in barebones it looks overengineered. 

9) Importance: minor,  type: corner cases / future proofing

Line 81-82, phase_history_analyser.py

if phases[i].T[-1] == highTemp:
                bHighTemperaturePhase[i] = True

is identifying high temp phases if their highest temp matches exactly hightemp. Could the highest temp be stored in different levels of precision such that some will get missed here?  I guess the way PT works this doesn't happen, but maybe it could happen if its replaced or changed with another tool?

10)  Importance: high, type: tidy, complete

Make sure we go through all TODO statements in code and either deal with them or at least make sure they do not sound alarming /  make things look bad / unfinished.  e.g. " # TODO: why was it necessary to do it this way?" (line 86, phase_history_analyser.py).  See also "# is it this simple? (added 15/11/2021)" (line 330, phase_history_analysis.py).


11)  Importance: medium but long term only, type: other use cases

 """for i in range(len(phases)):
            if phases[i].T[0] == 0.0:
                bLowTemperaturePhase[i] = True"""
 (line 94--96, phase_history_analyser.py)

This assumes the low temperature is T=0. This may not be desired if we consider higher scale PTs and maybe don't want to go to T=0?  I don't understand whats going in here anyway with the TODO comments etc.

12) Importance: low, type: code style, clarity

The method analysePhaseHistory_supplied has three outputs, paths, a bool and analysis metrics.  The code is written in such a way that the bool never gets a name in the code for this method, which could lead to confusion / mistakes later.  I think the bool is meant to be False when the paths were successful found and True when there is an error. maybe we could set Error = True or Error = False first and then pass it?      


13) Importance: high, type: calculation consistency

We need to make sure  the treatment of vw is consistent throughout all parts of the code.  I hope we can allow the user to choose:

i) to input any fixed value of vw between 0 and 1, throwing an error if exactly 1  or too close to q is used when it will cause  a problem for our numerics (this is in the hydrodynamics parts right?) 

ii) select the Chapman-Jouguet velocity which varies with temperature consistently throughout the code.

I *think* it does mostly work this way now with getBubbleWallVelocity returning the CJ vw when theflag bUseChapmanJouguetVelocity is set True and the user set vw otherwise.  However the fact that the Chapman-Jouguet velocity is indicated via a flag bUseChapmanJouguetVelocity, but you still pass a vw to the phase history analyser (in e.g. line  137 of the command_line_interface so) means:

a) I need to check carefully that the user input vw is not being used anywhere when  bUseChapmanJouguetVelocity = True 

b) Even if that is checked and all good, its a bit confusing for users  to do it this way and I think will lead to future developers wanting to carefully check the same thing or to potentially introduce bugs, so I think we should discuss other design options. 

Edit later:  I think this is not done consistently in the gws module because there it still seems to use the determineBubbleWallVelocity which is just fixing it to a number!  This should really be fixed, it takes the one from getBubbleWallVelocity and we just resect it if its 1 to some thing clkose that works and flag this to the user (I think reset in getBubbleWallVelocity and use same value everyhwere).


## DONE
## 14) Importance: low, type: user instructions

## Should we write the python command as "python3" in the README and
## manual?  I guess python3 will work for all users but "python" will
## not work for users who still have that set to python2. That
## actually applies to my local setup though i guess as we go forward
## python2 is getting abandoned so this will apply ti fewere and fewer
## people.  Just thought of it when looking at another python code we
## may want to interface to at some point, fastPTA
## https://github.com/Mauropieroni/fastPTA/ where they write it that
## way in the README.




15) Importance: high, type: code base

As well as the TODO statemenst there are many places in the code where triple quotes are around code.  See line 94--96 and lines 132-150  of phase_history_analysis.py and lines 796 -- 852, 1196--1228, 1328--1331, 1883-1893 of transition_analysis.py.  Sometimes but not always they are preceded by a #TODO and I presume this is code that is not ready yet.  These need to be dealt with before release.

16)  Importance: medium, type: generalise

Avoid hardcoding numbers here

maxSonTThreshold = self.estimateMaximumSignificantSonT() + 80
minSonTThreshold = 80.0
toleranceSonT = 3.0

17)  Importance: low  type: user interface

We have made booleans to do with contributions in the models a fundamental part of our user interface, e.g,  bUseBoltzmannSuppression being an argument in our command line interface which works for a number of models.  This seems a bit awkward, especially for extending to new models.    It would be nice to imagine a general command line user interface that only relied on the existence of a model. Thats a clever coding task someone unfamiliar with the rest of the code could do, but its also not very urgent 
  
## DONE
## 18) Importance: low, type: clean up

## The command_line_interface.py where PT is called is messy with
## commented out bits.  Tbh it looks like mess I had in when I was
## editing this by hand to work on ubuntu but git blame says I was not
## the last pesron to edit it.
## 
## Anyway lets clean this up.
 
19) Importance: medium, type: user interface

-subcrit option never passed to PT in any of our user interfaces.


20) Importance: low , type: model RSS defaults

Why is temperature scale set to 300 for RSS?  In general I think this should just be the expected physics scale.  We should think what to say to user about these settings in general (Cheng has been asking about them a lot while writing a new model file).   PA: Could change to VEV or say explicitly when describing in RSS model bit that i write now that this is jist roughly the VEV but a bit bigger. 

21) Importance: low to medium, type: settings / user understanding

Need to decide what to tell users about the setting .massShiftHack. We need to somehow communicate details like this as the user will see these options when trying to follow how to add new models, though this is specific to our implementation of the potential.    This is to avoid problems when you want to consider very small masses and need to have minMassThreshold set very low (10^{-10} according to comment.  Then numerical noise may give a non-zero mass to the goldstone and that may affect our results.  PA: this is a bit ugly but specific to model file, maybe we do not need to explain this, and that is an advantage of having the documentation rather than pointing people at these examples like I did Cheng.

22)  Importance: low to medium, type: user understanding

forbidPhaseCrit --   explain purpose of this, ie explain why we allow slightly negative values, which is because blocking off zero means it misses phi=0 minima which due to numerics can be slightly negative.

23) Importance: medium, type: error handling

The cause of errors being a PT failure  is not reported (and nor is the error from PT in any way) when there is a  pre-existing PhaseStraucture.dat file.  Maybe user stupidity but its happpened a few times so maybe we can catch this somehow? PA: we need to look into grabbing the std::err and doing something with it.  PA look into this get back to Lachlan. Plan: Check for non-empty std::err, and print message and halt. Add TS flag to force it contnue if the suer want to ignore these. OR Delete old phasetracer.dat file when runnung TS.    

24)  Importamce: medium, type: tidy

We have an empty method in the TransitionFinder class of PhaseTracer TransitionFinder::validateTransition.  The comments are also odd, looks like Lachlan started writing the explanation of what it should do in comments and them chnaged his mind in the middle of typing and wrote an alternative suggestion instead.   Needs to be tidied up!

We should probably just delete this...

## FIXED! 25) In PT model RSS.hpp we hardcode the topquark mass and
## bottom mass twice, once in setCouplingsAndScale() and once in
## get_fermion_masses_sq.  We really should avoid doing that...

26)  The model used for RSS in TransitionSolver is RealScalarSingletModel_Boltz in real_scalar_singlet_model_boltz.py.  However real_scalar_singlet_model.py still exists.  I don't like deleting the old file if its its simpler to understand but I do think we should tidy this up somehow. Otherwise users/readers  may get confused like I did: Actually comparing RSS.hpp and real_scalar_singlet_model.py, it looks like the latter does not set the fermion masses in the same way and only as the top quark, whereas RSS has all fermion masses, but for set couplings has only top and bottom.  

## Not needed now - we never actually rely on a hardcoded h just h/H0 so i removed h 
## 27) Importance: low but easy, type: user interface
## When we are making some thing easier to change for the user we
## chould make sure we include the Hubble parameter today.  There is
## this Hubble tension... It can be easily changed in determineGWs
## right now (line 188).

28) For future we can remove bag mnodel assumptions from evey place we use the time-temperature relatation, e.g. our most derived form of the JMAK equation.  

29) Importance: medium, but maybe for future, type: calculations
We could easily add the other fit values for the bubble collisions from the paper we use.  Maybe its fast to do for this paper. Also can add analytical calculation of the Bubble collison, GW peak amplitide and peak frequency from https://arxiv.org/abs/2107.01845.  This requires coding up their integral as they don't give a fit formulae, so maybe a little mini project for student.   

## DONE
## 30) If we use Omeha h^2 for "peak amplitude" we should be
## clear about what value of little h we take?  I think at least
## because we need to add it for the regular lattice sound wave fit we
## should, but i need tio check if actually they have somnehow used a
## specific factor of h^2 and we should really be undoing that...

## Answer: In the redshift we don't use the h=0.674 input to get the
## numerical factors because it cancels out.  We then must multiply by
## h^2 to get Omega h^2.  So we need to state the h^2 we use in the
## GWs section and not the redshift factor sectuio.

## DONE
## 31) We hardcode a numerical value fo3 h in line 185, and this is then used in H0 in line 188 and in line 194, but actually it just cancels out.  We should edit this to change 
## self.redshiftAmp = (s0/s1)**(4/3) * (H1/H0)**2 * h**2
## to
## self.redshiftAmp = (s0/s1)**(4/3) * H1**2 * hoverH0**2
##  and just hardcode hoverH0 which is really just a scaling factor. That way it  doesn't appear like we depend on data for h and simplifies things a little

## DONE 
## But must fix in our GWreview on arxiv if not issue an erratum
## 32) The sound wave regular fit has a numerical prefactor for the
## peak amplitude which is missing a factor h^2, same as our review
## unfortunately.  The correct prefcator is given in the draft and I
## will fix this.

## DONE
## 33) The sound shell model prefcator is OK but we use \tilde{\omega}
## = 0.01 there while we use 0.012 for regular fit (this is the exact
## number suggested in the numerical simulation paper erratum).  Of
## course they give a range of values from the simulations and I think
## Lachlan picked 0.01 based on the different values in that table as
## a resonable choice, but I feel we should go with their choice
## unless we really want another number from the table as more
## suitable.  Eitehr way we should use the same in both cases.

34) Importance: low,  type: tidy
For calculating the hubble parameter we seem to have two methods in the TransitionAnalyser class and two functions defined at in transition_analyser.py presambly for use outside of the class.

Inside class we have :
calculateHubbleParameterSq(self, T: float) -> float
calculateHubbleParameterSq_fromHydro(self, hydroVars: HydroVars) -> float:

where the difference is just whether you use the stored value for rho_f from HydroVars or call the function for getting the energy density from the hydrodynamics module.  However note in the latter we then subtract explicitly the ground state energy.  When getting it from HydroVars this has presuambly already been done (see later points delving into this)?  Anyway thats a bit messy maybe.  Possibly better to store ground state energy and  rho_f without subtraction and put them together here?    

Outside class we have:
* calculateHubbleParameterSq
* calculateHubbleParameterSq_supplied

I guess these are when you don't want to use the transition_analysis class.  But if we can have these as just functions do we need the methods?  Seems a bit messy but maybe all four needed somehow?



35)  Importance: low,  type: tidy

It can be hard tp see where we are setting energyDensityFalse in HydroVars such that we subtract the ground state energy.  In getHydroVars_new  we introduce FED_f and FED_t that we do this subtraction, but its easy to miss as we then redefine
Ffm = FED_f(T)
Ftm = FED_t(T)
Should be made more transparent if possible

## DONE:
## 36)

37)  Importance: medium,  type: stabilty
In hydrodybamics there are lots of places where we use the definition of the derivative to compute derivatives numerically.  But we don't ever check for problems.  it seems we are choosing step sizes carefully but still I expect these could fall over sometimes, shouldn't we catch such problems?  See e.g, calculateEnergyDensityAtT_singlePhase_supplied for an example!


38) Importance: low,  type: tidy
In hydrodynamics there are two routines for getting the variables:
* getHydroVars
* getHydroVars_new
The latter seems to be a new more efficient version and this one also subtracts off the ground state energy for the energy density while the former does not. However the former still seems to be used in line 112 to get the values for the reheating
self.hydroVarsReh = hydrodynamics.getHydroVars(self.fromPhase, self.toPhase, self.potential, self.Treh)
which is used to get the entropy.
Should be consistent. 


39) Importance: low to medium,  type: settings/hardcoding
completionThreshold is set to 1e-2 inside analyseTransition in transition_analysis.py.  We should instead replace this line with a call to get a setting and only the default of that setting should be 0.01.


40) Importance: medium,  type: samplimg/ generality

Check reliability of our routine transitionCouldComplete fpor models with different action curves.  make sure it does not sometimes rule out completion  incorrectly based on the assumptions made inside it. 


41) Importance: high,  type: samplimg/ generality

Make sure we catch and handle errors that come from  numerical
routines that may throw errors / go wrong. For example we call toms748
in calculateReheatTemperature.  I think we did have to catch errors
from a C++ implementation of this (in boost I think?) so surely we can
have issues from the scipy.optimise one too?


42) Importance: high,  type: error handling
We get this non-fatal error message output a number of times when running the gws part of the code:

intdy--  t (=r1) illegal      
      in above message,  r1 =  0.9937174800926D+00
      t not in interval tcur - hu (= r1) to tcur (=r2)       
      in above,  r1 =  0.9937174800926D+00   r2 =  0.9936930671188D+0

Need to handle this

