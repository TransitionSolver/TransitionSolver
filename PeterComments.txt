List of possible improvements

1)  Importance: Not urgent ;  type: Interfacing improvement ; 
Currently we only interface PhaseTracer and TranbsitionSolver via text file output, would be better to pass directly and ensure maximum effiency.    On PT side  should add a routine to return phase_structure object rather than writing to file.

2) Importance: minor; type: examples tidy up 

When I run the barebones example I first get an empty figure pop up and then only after I close it do i get the proper figures appearing.    Possibly its an issue with my texlive distribution.

## DONE: variation is from PhaseTracer numerics, we know about these and can set seed  
## 4 ) Importance: medium; type: understanding numerics
##  Results vary slightly from run to run, which may make users
##  suspicious and is annoying for testing.
##  But we may also need to quantify the degree to which they match
##  to avoid users thinking small deviations that come from numerical
##  noise means it can't work

## IGNORE/RESOLVED
## 5) Importance: minor; type: output tidy up ;  status: addressed

## Actually most output is switched off by setting bDebug = False.

## I think its not desirable to always print so much to screen while
## the code runs.  Can we make an option to pipe to some log file.
## Check this is not already done in scan code.

# 6) Importance: low ; type: user illustration improvement ; status:
# addressed
# I just added a comment explaining how to do this above the one in
# barebones example. Maybe that is enough.

# Do we or could we add an example where we just enter the
# parameterPoint in code rather than loading from file? (I just
# deleted some commented out code that looked like this...). Without
# this I think a user would need to look into the code (check this
# makes sense before adding)


## IGNORE/RESOLVED:
## 7)  Importance: low to medium; type: code confusion or memory efficiency

## Why have phaseStructure output by the load_data method of
## phaseStructure, seems odd " bFileExists, phaseStructure =
## phase_structure.load_data".  Does this mean we have two copies of this
## object in memory? Looking inside this method load_data does construct
## a phaseStructure object inside it.  Actually I see no reason why
## load_data should be a method of phaseStructure when its written this
## way.

## OK I just looked at this again, it seems the simple asnwer is
## load_data is not a method of the class PhaseStructure, as indictaed
## by the lack of indentation. Its just a function thats defined in
## the same file (module I guess).  I think the confusion here is the line:

##  bFileExists, phaseStructure =
##  phase_structure.load_data(outputFolder + '/phase_structure.dat',
##  bExpectFile=True)

## To me this looked like a phase_structure object calling a method.
## But its not its a function from the imported module
## phase_structure being called.  That function the creates an object
## from the class PhaseStructure which is the second of the two
## outputs.


8)  Importance: low; type: code style

The notifyHandler and notify_TransitionAnalyser_on_create is something I am not used to.  After reading I think this could be replaced in barebones example by juts passing a Boolean flag (or set of flags) that is later used to set bComputeSubsampledThermalParams.  Maybe there is some utility to this fancy machinery later on, but in barebones it looks overengineered. 

9) Importance: minor,  type: corner cases / future proofing

Line 81-82, phase_history_analyser.py

if phases[i].T[-1] == highTemp:
                bHighTemperaturePhase[i] = True

is identifying high temp phases if their highest temp matches exactly hightemp. Could the highest temp be stored in different levels of precision such that some will get missed here?  I guess the way PT works this doesn't happen, but maybe it could happen if its replaced or changed with another tool?

10)  Importance: high, type: tidy, complete

Make sure we go through all TODO statements in code and either deal with them or at least make sure they do not sound alarming /  make things look bad / unfinished.  e.g. " # TODO: why was it necessary to do it this way?" (line 86, phase_history_analyser.py).  See also "# is it this simple? (added 15/11/2021)" (line 330, phase_history_analysis.py).



11)  Importance: medium but long term only, type: other use cases

 """for i in range(len(phases)):
            if phases[i].T[0] == 0.0:
                bLowTemperaturePhase[i] = True"""
 (line 94--96, phase_history_analyser.py)

This assumes the low temperature is T=0. This may not be desired if we consider higher scale PTs and maybe don't want to go to T=0?  i don't understand whats going in here anyway with the TODO comments etc.

12) Importance: low, type: code style, clarity

The method analysePhaseHistory_supplied has three outputs, paths, a bool and analysis metrics.  The code is written in such a way that the bool never gets a name in the code for this method, which could lead to confusion / mistakes later.  I think the bool is meant to be False when the paths were successful found and True when there is an error. maybe we could set Error = True or Error = False first and then pass it?      


13) Importance: high, type: calculation consistency

We need to make sure we are happy with the treatment of vw and that it is consistent throughout all parts of the code.  I hope we can allow the user to choose:

i) to input any fixed value of vw between 0 and 1, throwing an error if exactly 1  or too close to q is used when it will cause  a problem for our numerics (this is in the hydrodynamics parts right?) 

ii) select the Chapman-Jouguet velocity which varies with temperature consistently throughout the code.

I *think* it does mostly work this way now with getBubbleWallVelocity returning the CJ vw when theflag bUseChapmanJouguetVelocity is set True and the user set vw otherwise.  However the fact that the Chapman-Jouguet velocity is indicated via a flag bUseChapmanJouguetVelocity, but you still pass a vw to the phase history analyser (in e.g. line  137 of the command_line_interface so) means:

a) I need to check carefully that the user input vw is not being used anywhere when  bUseChapmanJouguetVelocity = True 

b) Even if that is checked and all good, its a bit confusing for users  to do it this way and I think will lead to future developers wanting to carefully check the same thing or to potentially introduce bugs, so I think we should discuss other design options. 

Edit later:  I think this is not done consistently in the gws module because there it still seems to use the determineBubbleWallVelocity which is just fixing it to a number!  This should really be fixed it takes the one from getBubbleWallVelocity and we just resect oit if its 1 to some thing clkose that works and flag this to the user (I think reset in getBubbleWallVelocity and use same value everyhwere).


## DONE
## 14) Importance: low, type: user instructions

## Should we write the python command as "python3" in the README and
## manual?  I guess python3 will work for all users but "python" will
## not work for users who still have that set to python2. That
## actually applies to my local setup though i guess as we go forward
## python2 is getting abandoned so this will apply ti fewere and fewer
## people.  Just thought of it when looking at another python code we
## may want to interface to at some point, fastPTA
## https://github.com/Mauropieroni/fastPTA/ where they write it that
## way in the README.




15) Importance: high, type: code base

As well as the TODO statemenst there are many places in the code where triple quotes are around code.  See line 94--96 and lines 132-150  of phase_history_analysis.py and lines 796 -- 852, 1196--1228, 1328--1331, 1883-1893 of transition_analysis.py.  Sometimes but not always they are preceded by a #TODO and I presume they are effectively commented out code that is not ready yet, though technically triple quotes are not comments and are read by the interpreter as a long string.   
Anyway obviously these need to be dealt with before release.

16)  Importance: don't know, type: question

What is the meaning of the hard coded numbers here? Could they in any way be scenario specific?  

maxSonTThreshold = self.estimateMaximumSignificantSonT() + 80
minSonTThreshold = 80.0
toleranceSonT = 3.0

17)  Importance: low  type: user interface

We have made booleans to do with contributions in the models a fundamental part of our user interface, e.g,  bUseBoltzmannSuppression being an argument in our command line interface which works for a number of models.  This seems a bit awkward, especially for extending to new models.    It would be nice to imagine a general command line user interface that only relied on the existence of a model. Thats a clever coding task someone unfamiliar with the rest of the code could do, but its also not very urgent 
  
## DONE
## 18) Importance: low, type: clean up

## The command_line_interface.py where PT is called is messy with
## commented out bits.  Tbh it looks like mess I had in when I was
## editing this by hand to work on ubuntu but git blame says I was not
## the last pesron to edit it.
## 
## Anyway lets clean this up.
 
19) Importance: medium, type: user interface

-subcrit option never passed to PT in any of our user interfaces as far as I could tell when looking with Cheng. 


20) Importance: low to medium, type: model RSS defaults

Why is temperature scale set to 300 for RSS?  In general I think this should just be the expected physics scale.  We should think what to say to user about these settings in general (Cheng has been asking about them a lot while writing a new model file).   PA: Could change to VEV or say explicitly when describing in RSS model bit that i write now that this is jist roughly the VEV but a bit bigger. 

21) Importance: low to medium, type: settings / user understanding

Need to decide what to tell users about the setting .massShiftHack. We need to somehow communicate details like this as the user will see these options when trying to follow how to add new models, though this is specific to our implementation of the potential.    This is to avoid problems when you want to consider very small masses and need to have minMassThreshold set very low (10^{-10} according to comment.  Then numerical noise may give a non-zero mass to the goldstone and that may affect our results.  PA: this is a bit ugly but specific to model file, maybe we do not need ti explain this, and that is an advanc=tahge of having the documentation rather than pointing people at these examples like I did Cheng.

22)  Importance: low to medium, type: user understanding

forbidPhaseCrit --  I don't understand this one myself yet.  Why only check 0 component in RSS, in general why allow slightly negative, isn't this to avoid critical temps between z2 mirrors ?  PA: blocking off zero means the miss phi=0 minima due to numerics (slightly negative),

23) Importance: medium, type: error handling

The cause of errors being a PT failure  is not reported (and nor is the error from PT in any way) when there is a  pre-existing PhaseStraucture.dat file.  Maybe user stupidity but its happpened a few times so maybe we can catch this somehow? PA: we need to look into grabbing the std::err and doing something with it.  PA look into this get back to Lachlan. Plan: Check for non-empty std::err, and print message and halt. Add TS flag to force it contnue if the suer want to ignore these. OR Delete old phasetracer.dat file when runnung TS.    

24)  Importamce: medium, type: tidy

We have an empty method in the TransitionFinder class of PhaseTracer TransitionFinder::validateTransition.  The comments are also odd, looks like Lachlan started writimng the explanation of what it should do in comments and them chnaged his mind in the middle of typing and wrote an alternative suggestion instead.

We should probably just delete this...

## FIXED! 25) In PT model RSS.hpp we hardcode the topquark mass and
## bottom mass twice, once in setCouplingsAndScale() and once in
## get_fermion_masses_sq.  We really should avoid doing that...

26)  The model used for RSS in TransitionSolver is RealScalarSingletModel_Boltz in real_scalar_singlet_model_boltz.py.  However real_scalar_singlet_model.py still exists.  I don't like deleting the old file if its its simpler to understand but I do think we should tidy this up somehow. Otherwise users/readers  may get confused like I did: Actually comparing RSS.hpp and real_scalar_singlet_model.py, it looks like the latter does not set the fermion masses in the same way and only as the top quark, whereas RSS has all fermion masses, but for set couplings has only top and bottom.  

## Not needed now - we never actually rely on a hardcoded h just h/H0 so i removed h 
## 27) Importance: low but easy, type: user interface
## When we are making some thing easier to change for the user we
## chould make sure we include the Hubble parameter today.  There is
## this Hubble tension... It can be easily changed in determineGWs
## right now (line 188).

28) For future we can remove bag mnodel assumptions from evey place we use the time-temperature relatation, e.g. our most derived from of the JMAK equation.  

29) Importance: medium, but maybe for future, type: calculations
We could easily add the other fit values for the bubble collisions from the paper we use.  Maybe its fast to do for this paper. Also can add analytical calculation of the Bubble collison, GW peak amplitide and peak frequency from https://arxiv.org/abs/2107.01845.  This requires coding up their integral as they don't give a fit formulae, so maybe a little mini project for student.   

## DONE
## 30) If we use Omeha h^2 for "peak amplitude" we should be
## clear about what value of little h we take?  I think at least
## because we need to add it for the regular lattice sound wave fit we
## should, but i need tio check if actually they have somnehow used a
## specific factor of h^2 and we should really be undoing that...

## Answer: In the redshift we don't use the h=0.674 input to get the
## numerical factors because it cancels out.  We then must multiply by
## h^2 to get Omega h^2.  So we need to state the h^2 we use in the
## GWs section and not the redshift factor sectuio.

## DONE
## 31) We hardcode a numerical value fo3 h in line 185, and this is then used in H0 in line 188 and in line 194, but actually it just cancels out.  We should edit this to change 
## self.redshiftAmp = (s0/s1)**(4/3) * (H1/H0)**2 * h**2
## to
## self.redshiftAmp = (s0/s1)**(4/3) * H1**2 * hoverH0**2
##  and just hardcode hoverH0 which is really just a scaling factor. That way it  doesn't appear like we depend on data for h and simplifies things a little

DONE but waiting on check from Lach;lan and then  I shoudl at least fix our GWreview on arxiv if not issue an erratum
32)  The sound wave regular fit has a numerical prefactor for the peak amplitude which is missing a factor h^2, same as our review unfortunately.  The correct prefcator is given in the draft and I will fix this.

DONE but waiting on Lachlan to confirm
33) The sound shell model prefcator is OK but we use \tilde{\omega} = 0.01 there while we use 0.012 for regular fit (this is the exact number suggested in the numerical simulation paper erratum).  Of course they give a range of values from the simulations and I think Lachlan picked 0.01 based on the different values in that table as a resonable choice, but I feel we should go with their choice unless we really want another number from the table as more suitable.  Eitehr way we should use the same in both cases.

34) For calculating the hubble paraneter we seem to have two methods in the TransitionAnalyser class and two functions defined at in transition_analyser.py presambly for use outside of the class.

Inside class we have :
calculateHubbleParameterSq(self, T: float) -> float
calculateHubbleParameterSq_fromHydro(self, hydroVars: HydroVars) -> float:

where the difference is just whether you use the stored value for rho_f from HydroVars or call the function for getting the energy density from the hydrodynamics module.  However note in the latter we then subtract explicitly the ground state energy.  When getting it from HydroVars this has presuambly already been done (see later points delving into this)?  Anyway thats a bit messy maybe.  Possibly better to store ground state energy and  rho_f without subtraction and put them together here?    

Outside class we have:
* calculateHubbleParameterSq
* calculateHubbleParameterSq_supplied

I guess these are when you don't want to use the transition_analysis class.  But if we can have these as just functions do we need the methods?  Seems a bit messy but maybe all four needed somehow?



35) I could not easily see where we are setting energyDensityFalse in HydroVars such that we subtract (or don't if thats the case) the ground state energy was. I think because I was searching for the full variabe name when its set as just ef.  I then realised in getHydroVars_new  we introduce FED_f and FED_t that we do this subtraction, but its easy to miss as we then redefine
Ffm = FED_f(T)
Ftm = FED_t(T)
In getHydroVars I don't see it being subtracted, so it must be this one? In fact it looks like getHydroVars is an old less efficient version of getHydroVars_new ?  Note here I mean the routines in hydrodynamics.py.  In transition_analysis.py there is a wrapper for calling getHydroVars_new from hydrodymnamics which is called getHydroVars.   Gets a bit confusing.


36) why does calculateEnergyDensityAtT_singlePhase take both phases as arguments and then calculate with only one after checking a boolean argument?  Why not just pass the phase you need?     Ah it needs the from_phase and the to_phase to compute Tstep.  I don't understand this part though...  Tstep seems to be for the numerical derivative.  I guess he can't use just one, as it might be at the origin and not give a good scale?  I'd like to understand the logic of Tstep though, but i don't follow looking at it quickly.


37) In hydrodybamics there are lots of places where we use the definition of the derivative to compute derivatives numerically.  But we don't ever check for problems.  it seems we are choosing step sizes carefully but still I expect these could fall over sometimes, shouldn't we catch such problems?  See e.g, calculateEnergyDensityAtT_singlePhase_supplied for an example!


38) In hydrodynamics there are two routines for getting the variables:
* getHydroVars
*getHydroVars_new
The latter seems to be a new more efficient version and this one also subtracts off the ground state energy for the energy density while the former does not. Hwever the former still seems to be used in line 112 to gte the vakues for the reheating
self.hydroVarsReh = hydrodynamics.getHydroVars(self.fromPhase, self.toPhase, self.potential, self.Treh)
which is used to get the entropy.  I am not sure why the old version is used here though. Is this intentional or it just doesn't matter?


39) completionThreshold is set to 1e-2 inside analyseTransition in transition_analysis.py.  We should instead replace this line with a call to get a setting and only the default of that setting should be 0.01.


40)  Some confusion below that I figurd out after reading and and have used to improve the comments in code (for other idiots like me).  But now I am worry -- how reliable is our routine transitionCouldComplete ?  Could this sometimes rule out completion  and be wriong based on the assumptions made inside it?  Maybe becauise we have a diferent action curve shape to what Lachlan expects?
------
## I don't understand in analyseTransition how the following line does
## what the comment above says?

## # Keep sampling until we have identified the end of the phase
#         transition or that the transition doesn't complete.  while
#         not self.bCheckPossibleCompletion or
#         self.transitionCouldComplete(maxSonTThreshold +
#         toleranceSonT, Pf):
## The second bit is clear as long as that is true we continue. I
## guess there is check inside the routine for completion being
## reached.  But the firts bit seems to continue only if
## bCheckPossibleCompletion is false, ie we keep the whle loop going
## when we do *not* want to check completion?  I don't get it....
## Also maybe some brackers around "not self.bCheckPossibleCompletion"
## would avoid readers having to double check order of the not and or?

## So the flag bCheckPossibleCompletion is currently true. This means
## not bCheckPossibleCompletion is False. So the the logic of the OR
## statement means its true if transitionCouldComplete is true and
## false if its false.  So we continue as lonsg as the transition
## could complete.  If bCheckPossibleCompletion is set to false then
## we would always continue regardless so this would just eb an
## infinte while loop that needs to be terminated by something in the
## body of it.  Based on the comment avout this flag trhat will be
## when T=0




41) I may have already put a comment asking about unguarded numerical
routines that may throw errors / go wrong. For example we call toms748
in calculateReheatTemperature.  I think we did have tio catch errors
from a C++ implementation of this (in boost I think?) so surely we can
have issues from the scipy.optimise one too?


42) I got confused about where we get the code for computing
kappa_{sw} from. Since we only account for the speed of sound in the
false vacuum varying (ie where they use the nu model), in priciple it
ought to be possible to get it from the paper where this was firts
done: 2004.06995 as they do supply a code snippet for this in that
paper.  However, Lachlan made some comments that seemed to say it was
from the follow up 2010.09744 where they do ythe numu model.  I
thought this was probbaly a typo in his comment but then I looked at
the code again (giese_kappa.py) and notcied the comment at the top
which says its copied from 2010.09744 so mits unlikely he got this
mixed up twice. i cpmpared the code to the code in the appendices and
it does look more like the code in the appendix of 2010.09744, some
bits are just identiocal but it seems he made some extra functions to
also just do the nu model. So as far as I can tell giese_kappa.py
comes from 2010.09744 but then has extra routines that ere wither
modified from the ones there to work with the simpler nu model or were
taken from 2004.06995 and repackaged to fit there?  IO don'yt know how
to describe this so I need to chat to Lachlan and get clarification.

43) I am concerned about our use of K in bubble collsions, doesn't
that mean we use the efficiency factor from sound waves?  Shouldn't we
replace K -> K / kappa ?  I am fairly sure we need to fix this.  PA: we were already doing something but PA will swutch ti nsuing version which inclorporates delta, but uses kappa_{coll}.

44) I get this seemingly non-fatal error message output a number of times when running the gws part of the code:

intdy--  t (=r1) illegal      
      in above message,  r1 =  0.9937174800926D+00
      t not in interval tcur - hu (= r1) to tcur (=r2)       
      in above,  r1 =  0.9937174800926D+00   r2 =  0.9936930671188D+0

I only noticed it yesterday but I checked I get it going all the way back to commit 19ad19244ae419e919636ed98b391d3c571e319e .  

It seems like an error from a dependent package used for the integration but I haven't learned much chucking it into google.

Possibly I really didn't see it before and its a new thing coming from an update to the dependent package i have installed locally?

PA: we also noticed the rest of the output also has an (obsure) error message.  Both Lachlan and Peter will look into this again.


