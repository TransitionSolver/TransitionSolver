"""
PhaseTracer interface using system calls
========================================
"""

import os
from pathlib import Path
import subprocess

import numpy as np

from .analysis.phase_structure import Phase, Transition, PhaseStructure


CWD = os.path.dirname(os.path.abspath(__file__))

PT_HOME = Path(os.getenv("PHASETRACER", Path.home() / ".PhaseTracer"))
PT_LIB = PT_HOME / "lib" / "libphasetracer.so"
PT_INCLUDE = PT_HOME / "include"
EP_HOME = PT_HOME / "EffectivePotential"
EP_INCLUDE = EP_HOME / "include" / "effectivepotential"
EP_MODELS = EP_HOME / "include" / "models"
EP_LIB = EP_HOME / "lib" / "libeffectivepotential.so"
CXX = "g++"
TEMPLATE_CPP = os.path.join(CWD, "interface.cpp")
LIBS = [EP_LIB, PT_LIB, "-lboost_log", "-lboost_filesystem", "-lnlopt"]
PT_UNIT_TEST = PT_HOME / "bin" / "unit_tests"


def rpath(name):
    """
    @returns Compiler arugment to add an rpath
    """
    return f"-Wl,-rpath={name}"


def build_phase_tracer(model, model_header=None, model_lib=None, model_namespace="EffectivePotential", force=False):
    """
    Build PhaseTracer model for use in TransitionSolver.
    
    @returns Path to built executable
    """
    exe_name = PT_HOME / model

    if os.path.exists(exe_name) and not force:
        return exe_name

    cpp_name = os.path.join(PT_HOME, f"{model}.cpp")

    with open(TEMPLATE_CPP, 'r', encoding='utf-8') as f:
        template = f.read()

    to_add = "// do not edit this file - edit the template instead\n\n"

    if model_header is not None:
        to_add += f"#include \"{model_header}\"\n\n"

    with open(cpp_name, 'w', encoding='utf-8') as f:
        f.write(to_add + template)

    cmd = [CXX, cpp_name, "-o", exe_name, "-I", PT_INCLUDE, "-I", EP_MODELS, "-I", EP_INCLUDE, rpath(EP_HOME / 'lib'), rpath(PT_HOME / 'lib')] + LIBS

    if model_lib:
        cmd.append(model_lib)

    if model_namespace:
        model = f"{model_namespace}::{model}"

    cmd.append(f"-DMODEL_NAME_WITH_NAMEPSPACE={model}")

    compile_ = subprocess.run(cmd, capture_output=True, text=True, check=False)

    if compile_.returncode != 0:
        raise RuntimeError(compile_.stderr)

    return exe_name


def run_phase_tracer(exe_name, point_file_name) -> PhaseStructure:
    """
    Run PhaseTracer and read serialzied data
    
    @returns PhaseTracer serialied output as string
    """
    run = subprocess.run([exe_name, point_file_name], capture_output=True, text=True, check=False)
    if run.returncode != 0:
        raise RuntimeError(run.stderr)
    return run.stdout


def read_path(data):
    """  
    @returns Transition path from lines of data
    """
    return [int(el[1:]) - 1 if el.startswith('-') else int(el) for el in data[0].split()]


def read_arr(data):
    """  
    @returns Array from lines of data
    """
    return np.squeeze(np.array([np.fromstring(d, sep=' ') for d in data]))


def read_phase_tracer(data) -> PhaseStructure:
    """
    Read serialised data from PhaseTracer
    """
    phases = []
    transitions = []
    paths = []

    parts = [part.split("\n") for part in data.strip().split("\n\n")]

    for part in parts:

        if not part[0].startswith("#"):
            raise RuntimeError(f"Could not read {part}")

        metadata = part[0].lstrip("#").strip()
        arr = part[1:]

        if not arr:
            continue

        try:
            label, key = metadata.split()
        except ValueError:
            label = metadata

        if label == "phase":
            phases.append(Phase(key, read_arr(arr)))
        elif label == "transition":
            transitions.append(Transition(read_arr(arr)))
        elif label == "transition-path":
            paths.append(read_path(arr))
        else:
            raise RuntimeError(f"Could not read {part}")

    return PhaseStructure(phases, transitions, paths)
